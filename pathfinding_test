extends Node2D

var int_INF : int = 999999

var Navigable : Node
var NavigationGrid : Array
var NavWeightsGrid : PoolIntArray

var neighbors 		: Array = []
var index_in_grid 	: PoolIntArray = []

func _ready():
	Navigable = get_node("Navigable")
	gather_navigationTilemaps()

func _input(event):
	if event is InputEventMouseButton:
		if (event.button_index == BUTTON_LEFT and event.pressed):
			var Start_position = $TestHero.global_position
			var End_position = target_position(event, NavigationGrid)
			Dijkstra(NavigationGrid, NavWeightsGrid, Start_position, End_position)

func gather_navigationTilemaps():
	var Tiles_array: PoolVector2Array = []
	var weights_array : PoolIntArray = []
	
	var NavTilemaps = Navigable.get_children()
	
	for i in NavTilemaps.size():
		NavTilemaps[i].fix_invalid_tiles()
		var TM_cells = NavTilemaps[i].get_used_cells()
		
		var weight_list : PoolIntArray = []
		weight_list.resize(TM_cells.size())
		for j in TM_cells.size():
			weight_list[j] = NavTilemaps[i].weight
			
			var Tile_Center = Vector2(
								32* (TM_cells[j].x - TM_cells[j].y),
								16* (1+ TM_cells[j].x + TM_cells[j].y)
								)
			TM_cells[j] = Tile_Center
		
		Tiles_array.append_array(TM_cells)
		weights_array.append_array(weight_list)
	
	NavigationGrid = Tiles_array
	NavWeightsGrid = weights_array
#	return [Tiles_array, weights_array]


func target_position(event, Tiles):
	var newGoal : Vector2
	var clickPosition_global = Vector2(
								round(event.position.x/32)*32, 
								round(event.position.y/16)*16)
	for i in Tiles.size():
		var Tile_Center = Tiles[i]
#		var Tile_Center = Vector2(
#							32*(Tiles[i].x - Tiles[i].y),
#							16* (1+ Tiles[i].x + Tiles[i].y)
#							)
		
		if (abs(Tile_Center.x - clickPosition_global.x) <= 33
		and abs(Tile_Center.y - clickPosition_global.y) <= 17):
			newGoal = Tile_Center
			break
	return newGoal


func Dijkstra(Grid, Grid_weights, Start_position, End_position):
	var search_index 	: int = -1
	var start_index 	: int = -1
	var end_index 		: int = -1
	# var unchecked_Grid : PoolVector2Array = Grid
	var result_Grid 	: PoolIntArray = []
	
	# INITIALIZE
	for i in Grid.size():
		result_Grid.append(int_INF)
		if Grid[i] == Start_position:
			start_index = i
			search_index = i
		if Grid[i] == End_position:
			end_index = i
	
	# WEIGH CELLS
	# relatively to start cell.
	var while_count : int = 0
	var temp_Grid = Grid.duplicate()
	result_Grid[search_index] = 0
	while while_count <=1000:
		while_count+=1
		find_neighborTiles(temp_Grid[search_index], Grid)
		temp_Grid.remove(search_index)
		
		var current_min     : int = int_INF
		var current_min_ind : int = int_INF
		for i in neighbors.size():
			var weight : int = Grid_weights[index_in_grid[i]]
			var current_result : int
			current_result = result_Grid[search_index] + weight
			
			if current_result < result_Grid[index_in_grid[i]]:
					result_Grid[index_in_grid[i]] = current_result
			
			if current_result < current_min:
				current_min = current_result
				current_min_ind = index_in_grid[i]
		
		search_index = current_min_ind
		
		if  search_index == end_index:
			while_count = 1002
	
	# CHOSE PATH
	# starting from destination
	var path : Array = [Grid[search_index]]
	if  search_index == end_index:
		find_neighborTiles(Grid[search_index], Grid)
		
		while search_index != start_index:
			var current_min     : int = int_INF
			var current_min_ind : int = int_INF
			find_neighborTiles(Grid[search_index], Grid)
			for i in neighbors.size():
				if result_Grid[index_in_grid[i]] < current_min:
					current_min = result_Grid[index_in_grid[i]]
					current_min_ind = index_in_grid[i]
				
				# warning-ignore:return_value_discarded
				path.push_front(Grid[current_min_ind])
				search_index = current_min_ind
		
	else:
		print("No path found")
	
	
	return path
			

func find_index(ArrayIn : Array, Adress: Vector2):
	var indexOut : PoolVector2Array
	for i in ArrayIn.size():
		if ArrayIn[i] == Adress:
			indexOut = i
			break
	return indexOut

func find_neighborTiles(currentTile : Vector2, Tiles_array: Array):
	var neighbour_count : int = 0
	var neighbours : PoolVector2Array = []
	var neighbours_index : PoolIntArray = []
	
	for i in Tiles_array.size():
		if (abs(Tiles_array[i].x - currentTile.x) < 1
		and abs(Tiles_array[i].y - currentTile.y) < 1):
			continue
		
		if (abs(Tiles_array[i].x - currentTile.x) < 65
		and abs(Tiles_array[i].y - currentTile.y) < 1):
			neighbour_count += 1
			neighbours.push_back(Tiles_array[i])
			neighbours_index.push_back(i)
			continue # ^ horizontally aligned ^
		
		if (abs(Tiles_array[i].x - currentTile.x) < 1
		and abs(Tiles_array[i].y - currentTile.y) < 33):
			neighbour_count += 1
			neighbours.push_back(Tiles_array[i])
			neighbours_index.push_back(i)
			continue # ^ vertically aligned ^
		
		if (abs(Tiles_array[i].x - currentTile.x) <= 33
		and abs(Tiles_array[i].y - currentTile.y) <= 17):
			neighbour_count += 1
			neighbours.push_back(Tiles_array[i])
			neighbours_index.push_back(i)
			continue
		
		if neighbour_count == 8 :
			break
	
	neighbors = neighbours
	index_in_grid = neighbours_index
#	return [neighbours, neighbours_index]
