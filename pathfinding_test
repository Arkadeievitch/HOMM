extends Node2D

var int_INF : int = 999999

var Navigable : Node
var NavigationGrid : Array
var NavWeightsGrid : PoolIntArray

# var neighbors 		: Array = []
# var index_in_grid 	: PoolIntArray = []

var hero_path : Array = []

func _ready():
	Navigable = get_node("Navigable")
	gather_navigationTilemaps()

func _input(event):
	if event is InputEventMouseButton:
		if (event.button_index == BUTTON_LEFT and event.pressed):
			var Start_position = $TestHero.global_position
			var End_position = target_position(event, NavigationGrid)
			Dijkstra(NavigationGrid, NavWeightsGrid, Start_position, End_position)
			
			var PathLine = $TestHero/Line2D
			var hero_path_local = hero_path.duplicate()
			for i in hero_path_local.size():
				hero_path_local[i] = $TestHero.to_local(hero_path_local[i])
			PathLine.points = PoolVector2Array(hero_path_local)
			PathLine.show()

func gather_navigationTilemaps():
	var Tiles_array: PoolVector2Array = []
	var weights_array : PoolIntArray = []
	
	var NavTilemaps = Navigable.get_children()
	
	for i in NavTilemaps.size():
		NavTilemaps[i].fix_invalid_tiles()
		var TM_cells = NavTilemaps[i].get_used_cells()
		
		var weight_list : PoolIntArray = []
		weight_list.resize(TM_cells.size())
		for j in TM_cells.size():
			weight_list[j] = NavTilemaps[i].weight
			
			var Tile_Center = Vector2(
								32* (TM_cells[j].x - TM_cells[j].y),
								16* (1+ TM_cells[j].x + TM_cells[j].y)
								)
			TM_cells[j] = Tile_Center
		
		Tiles_array.append_array(TM_cells)
		weights_array.append_array(weight_list)
	
	NavigationGrid = Tiles_array
	NavWeightsGrid = weights_array


func target_position(event, Tiles):
	var newGoal : Vector2
	var clickPosition_global = Vector2(
								round(event.position.x/32)*32, 
								round(event.position.y/16)*16)
	for i in Tiles.size():
		var Tile_Center = Tiles[i]
#		var Tile_Center = Vector2(
#							32*(Tiles[i].x - Tiles[i].y),
#							16* (1+ Tiles[i].x + Tiles[i].y)
#							)
		
		if (abs(Tile_Center.x - clickPosition_global.x) <= 33
		and abs(Tile_Center.y - clickPosition_global.y) <= 17):
			newGoal = Tile_Center
			break
	return newGoal


func DIJKSTRA(Grid, Grid_weights, Start_position, End_position):
	var search_index 	: int = -1
	var start_index 	: int = -1
	var end_index 		: int = -1
	var result_Grid 	: PoolIntArray = []
	
	var neighbours : PoolVector2Array = []
	var neighbours_index : PoolIntArray = []
    
	# INITIALIZE
	for i in Grid.size():
		result_Grid.append(int_INF)
		if Grid[i] == Start_position:
			start_index = i
		if Grid[i] == End_position:
			end_index = i
	
	# WEIGH CELLS
	# relatively to start cell.
    # update result_Grid
	weigh_cells(Grid : Array, start_index : int, end_index : int, 
                result_Grid : PoolIntArray)
	
	
	# CHOSE PATH
	chosepath(Grid, start_index, end_index,
                hero_path)


func find_neighborTiles(currentTile : Vector2, Tiles_array: Array, Tiles2Pass: PoolBoolArray,
                        neighbours : Array, neighbours_index : PoolIntArray):
	var neighbour_count : int = 0
	# var neighbours : PoolVector2Array = []
	# var neighbours_index : PoolIntArray = []
	
	for i in Tiles_array.size():
		if ((abs(Tiles_array[i].x - currentTile.x) < 1
		and abs(Tiles_array[i].y - currentTile.y) < 1)
        or Tiles2Pass(i) == true):
			continue
		
		if (abs(Tiles_array[i].x - currentTile.x) < 65
		and abs(Tiles_array[i].y - currentTile.y) < 1):
			neighbour_count += 1
			neighbours.push_back(Tiles_array[i])
			neighbours_index.push_back(i)
			continue # ^ horizontally aligned ^
		
		if (abs(Tiles_array[i].x - currentTile.x) < 1
		and abs(Tiles_array[i].y - currentTile.y) < 33):
			neighbour_count += 1
			neighbours.push_back(Tiles_array[i])
			neighbours_index.push_back(i)
			continue # ^ vertically aligned ^
		
		if (abs(Tiles_array[i].x - currentTile.x) <= 33
		and abs(Tiles_array[i].y - currentTile.y) <= 17):
			neighbour_count += 1
			neighbours.push_back(Tiles_array[i])
			neighbours_index.push_back(i)
			continue
		
		if neighbour_count == 8 :
			break
	
	# neighbors = neighbours
	# index_in_grid = neighbours_index


func weigh_cells(Grid : Array, start_index : int, end_index : int, 
                result_Grid : PoolIntArray):
    # WEIGH CELLS
	# relatively to start cell.
	var while_count : int = 0
	var Grid_finished : PoolBoolArray = []
    for i in Grid.size():
        Grid_finished[i] = false
    
	result_Grid[start_index] = 0
    
    search_index = start_index
	while (search_index != end_index 
	and while_count <=1000):
		while_count+=1
        # update neighbours, neighbours_index
        Grid_finished(search_index) = true
		find_neighborTiles( Grid[search_index], Grid, Grid_finished
                            neighbours, neighbours_index)
		
		var current_min     : int = int_INF
		var current_min_ind : int = int_INF
		for i in neighbours.size():
            if size(neighbours, 1) > 1:
                Current_Neighbour = neighbours(i, :);
                Current_neighbour_index = neighbours_index(i);
            else:
                Current_Neighbour = neighbours;
                Current_neighbour_index = neighbours_index;
            
			var weight : int = Grid_weights[neighbours_index[i]]
			var current_result : int
			current_result = result_Grid[search_index] + weight
			
			if current_result < result_Grid[Current_neighbour_index]:
					result_Grid[Current_neighbour_index] = current_result
			
			if current_result < current_min:
				current_min = current_result
				current_min_ind = Current_neighbour_index
		
		search_index = current_min_ind

func chosepath(Grid, start_index, end_index,
                hero_path):
	# CHOSE PATH
	# starting from destination
	hero_path = [Grid[end_index]]
	search_index = end_index
	
	var neighbours : PoolVector2Array = []
	var neighbours_index : PoolIntArray = []
	var Grid_finished : PoolBoolArray = []
    for i in Grid.size():
        Grid_finished[i] = false
    
	while search_index != start_index:
		var current_min     : int = int_INF
		var current_min_ind : int = int_INF
        # update neighbours, neighbours_index
		find_neighborTiles( Grid[search_index], Grid, Grid_finished 
                            neighbours, neighbours_index)
		for i in neighbours.size():
			if result_Grid[neighbours_index[i]] < current_min:
				current_min = result_Grid[neighbours_index[i]]
				current_min_ind = neighbours_index[i]
				
        hero_path.push_front(Grid[current_min_ind])
        Grid_finished[current_min_ind] = true
        search_index = current_min_ind
    
