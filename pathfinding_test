extends Node2D

var int_INF : int = 999999

var Navigable : Node
var NavigationGrid : Array
var NavWeightsGrid : PoolIntArray

var neighbors 		: Array = []
var index_in_grid 	: PoolIntArray = []

var hero_path : Array = []

func _ready():
	Navigable = get_node("Navigable")
	gather_navigationTilemaps()

func _input(event):
	if event is InputEventMouseButton:
		if (event.button_index == BUTTON_LEFT and event.pressed):
			var Start_position = $TestHero.global_position
			var End_position = target_position(event, NavigationGrid)
			Dijkstra(NavigationGrid, NavWeightsGrid, Start_position, End_position)
			
			var PathLine = $TestHero/Line2D
			var hero_path_local = hero_path.duplicate()
			for i in hero_path_local.size():
				hero_path_local[i] = $TestHero.to_local(hero_path_local[i])
			PathLine.points = PoolVector2Array(hero_path_local)
			PathLine.show()

func gather_navigationTilemaps():
	var Tiles_array: PoolVector2Array = []
	var weights_array : PoolIntArray = []
	
	var NavTilemaps = Navigable.get_children()
	
	for i in NavTilemaps.size():
		NavTilemaps[i].fix_invalid_tiles()
		var TM_cells = NavTilemaps[i].get_used_cells()
		
		var weight_list : PoolIntArray = []
		weight_list.resize(TM_cells.size())
		for j in TM_cells.size():
			weight_list[j] = NavTilemaps[i].weight
			
			var Tile_Center = Vector2(
								32* (TM_cells[j].x - TM_cells[j].y),
								16* (1+ TM_cells[j].x + TM_cells[j].y)
								)
			TM_cells[j] = Tile_Center
		
		Tiles_array.append_array(TM_cells)
		weights_array.append_array(weight_list)
	
	NavigationGrid = Tiles_array
	NavWeightsGrid = weights_array


func target_position(event, Tiles):
	var newGoal : Vector2
	var clickPosition_global = Vector2(
								round(event.position.x/32)*32, 
								round(event.position.y/16)*16)
	for i in Tiles.size():
		var Tile_Center = Tiles[i]
#		var Tile_Center = Vector2(
#							32*(Tiles[i].x - Tiles[i].y),
#							16* (1+ Tiles[i].x + Tiles[i].y)
#							)
		
		if (abs(Tile_Center.x - clickPosition_global.x) <= 33
		and abs(Tile_Center.y - clickPosition_global.y) <= 17):
			newGoal = Tile_Center
			break
	return newGoal


func Dijkstra(Grid, Grid_weights, Start_position, End_position):
	var search_index 	: int = -1
	var start_index 	: int = -1
	var end_index 		: int = -1
	var result_Grid 	: PoolIntArray = []
	
	# INITIALIZE
	for i in Grid.size():
		result_Grid.append(int_INF)
		if Grid[i] == Start_position:
			start_index = i
			search_index = i
		if Grid[i] == End_position:
			end_index = i
	
	# WEIGH CELLS
	# relatively to start cell.
	var while_count : int = 0
	var temp_Grid = Grid.duplicate()
	result_Grid[search_index] = 0
	while (search_index != end_index 
	and while_count <=1000):
		while_count+=1
		find_neighborTiles(temp_Grid[search_index], Grid)
		temp_Grid.remove(search_index)
		
		var current_min     : int = int_INF
		var current_min_ind : int = int_INF
		for i in neighbors.size():
			var weight : int = Grid_weights[index_in_grid[i]]
			var current_result : int
			current_result = result_Grid[search_index] + weight
			
			if current_result < result_Grid[index_in_grid[i]]:
					result_Grid[index_in_grid[i]] = current_result
			
			if current_result < current_min:
				current_min = current_result
				current_min_ind = index_in_grid[i]
		
		search_index = current_min_ind
	
	
	# CHOSE PATH
	# starting from destination
	hero_path = [Grid[end_index]]
	search_index = end_index
	
	while search_index != start_index:
		var current_min     : int = int_INF
		var current_min_ind : int = int_INF
		find_neighborTiles(Grid[search_index], Grid)
		for i in neighbors.size():
			if result_Grid[index_in_grid[i]] < current_min:
				current_min = result_Grid[index_in_grid[i]]
				current_min_ind = index_in_grid[i]
				
				hero_path.push_front(Grid[current_min_ind])
				search_index = current_min_ind


func find_neighborTiles(currentTile : Vector2, Tiles_array: Array):
	var neighbour_count : int = 0
	var neighbours : PoolVector2Array = []
	var neighbours_index : PoolIntArray = []
	
	for i in Tiles_array.size():
		if (abs(Tiles_array[i].x - currentTile.x) < 1
		and abs(Tiles_array[i].y - currentTile.y) < 1):
			continue
		
		if (abs(Tiles_array[i].x - currentTile.x) < 65
		and abs(Tiles_array[i].y - currentTile.y) < 1):
			neighbour_count += 1
			neighbours.push_back(Tiles_array[i])
			neighbours_index.push_back(i)
			continue # ^ horizontally aligned ^
		
		if (abs(Tiles_array[i].x - currentTile.x) < 1
		and abs(Tiles_array[i].y - currentTile.y) < 33):
			neighbour_count += 1
			neighbours.push_back(Tiles_array[i])
			neighbours_index.push_back(i)
			continue # ^ vertically aligned ^
		
		if (abs(Tiles_array[i].x - currentTile.x) <= 33
		and abs(Tiles_array[i].y - currentTile.y) <= 17):
			neighbour_count += 1
			neighbours.push_back(Tiles_array[i])
			neighbours_index.push_back(i)
			continue
		
		if neighbour_count == 8 :
			break
	
	neighbors = neighbours
	index_in_grid = neighbours_index

